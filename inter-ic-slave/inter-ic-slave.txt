

          
          

――――――――――――――――――――――――――――――――――――――――――――――――――――――我是分割线――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――



I2C M     -----SDA------      I2C S          
          -----SCL------

INTER IC slave device要做的事

--每次接收到停止信号后，告诉应用层可以来取数据状态；并拉底SCL线让总线处于忙，让对方等，不接受新的数据发起，也不启动监测起始信号；
  等应用层取走数据后，才开始释放SCL线，开始接收新的数据发起，即开始监测起始信号；
  每次允许最多256个字节发送


--S方查询有没有数据，因为不是我发起的

--S收到一字节数据就上报，提醒应用来拿走，同时底下开个缓存，避免应用没及时取走导致前一字节被覆盖丢掉。多数情况应用会很快拿走，不会让数据在驱动中积压，所以M端尽管不停发好了。相当于门限定为1
S端CPU消耗会大些，不过可以设定一个结束约定，当通信结束不需要后，可以关闭该不需要的INTER IC查询数据线程。如果不需要驻留，不需要进行后续通信和传输了的话，是可以结束该线程释放CPU

--INTER IC速度很慢，最高才5Mb/s，程序查询应该足够比它快，应付得过来，来一字节读走一字节应该不是问题，即使偶尔来不及取走，设个64个的buf缓冲一下就可以，到时10几个一起读走。每次读走的个数不定，可能是1个，可能是3、5个
但对CPU消耗大，不过最好是批量读取，先简单，来一个收一个，不考虑太多CPU占用的事，先打通。应用端不停的查，有数据就读走。驱动端收到一字节数据就不停的上报。
应用端接收完字节就打印出来，或存到一个大数组，或malloc的内存去

--调试时可以先手动用i2c_write工具发一批数据，应用上把收到的数据打印出来




驱动要做的
  
--设计一个接收数据缓冲，先定256个字节吧
--时刻监测主机发起了通信，时刻监测时钟线SCL和数据线SDA，
--时刻监测主机停止了通信，时刻监测时钟线SCL和数据线SDA，
--把主机传过来的一比特一比特有效数据组合成一字节一字节数据DATA
--设置标志，告知应用层收到数据
--设置相关标志位，告知有多少数据在缓存中
--过滤掉设备地址寄存器地址等非有效数据字节
--发送ACK应答给主机
--检测读写信号（可先不做）
--GPIO复用寄存器配置，配置成GPIO使用――脚本中处理
--每次接收到停止信号后，拉底SCL线让总线处于忙状态，不监测起始信号
--应用层取走数据后，释放SCL线，开始监测起始信号；


应用层要做的
--程序启动时开启一个线程
--查询驱动有没有收到INTER IC数据
--取走数据




――――――――――――――――――――――――――――――――――――――――――――――――――――――我是分割线――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――


做一个INTER IC slave driver，与作为master的对端通信，接收数据

也即是做一个device


编写驱动

按照现在的GPIO模拟INTER IC，现在的速率有1/40us=25Mbit/s


